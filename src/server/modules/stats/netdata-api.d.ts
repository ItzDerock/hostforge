/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/api/v2/nodes": {
    /**
     * Nodes Info v2
     * @description Get a list of all nodes hosted by this Netdata agent.
     */
    get: operations["getNodes2"];
  };
  "/api/v2/contexts": {
    /**
     * Contexts Info v2
     * @description Get a list of all contexts, across all nodes, hosted by this Netdata agent.
     */
    get: operations["getContexts2"];
  };
  "/api/v2/q": {
    /**
     * Full Text Search v2
     * @description Get a list of contexts, across all nodes, hosted by this Netdata agent, matching a string expression
     */
    get: operations["q2"];
  };
  "/api/v1/info": {
    /**
     * Node Info v1
     * @description The info endpoint returns basic information about netdata. It provides:
     * * netdata version
     * * netdata unique id
     * * list of hosts mirrored (includes itself)
     * * Operating System, Virtualization, K8s nodes and Container technology information
     * * List of active collector plugins and modules
     * * Streaming information
     * * number of alarms in the host
     *   * number of alarms in normal state
     *   * number of alarms in warning state
     *   * number of alarms in critical state
     */
    get: operations["getNodeInfo1"];
  };
  "/api/v1/charts": {
    /**
     * List all charts v1 - EOL
     * @description The charts endpoint returns a summary about all charts stored in the netdata server.
     */
    get: operations["getNodeCharts1"];
  };
  "/api/v1/chart": {
    /**
     * Get one chart v1 - EOL
     * @description The chart endpoint returns detailed information about a chart.
     */
    get: operations["getNodeChart1"];
  };
  "/api/v1/contexts": {
    /**
     * Get a list of all node contexts available v1
     * @description The contexts endpoint returns a summary about all contexts stored in the netdata server.
     */
    get: operations["getNodeContexts1"];
  };
  "/api/v1/context": {
    /**
     * Get info about a specific context
     * @description The context endpoint returns detailed information about a given context.
     * The `context` parameter is required for this call.
     */
    get: operations["getNodeContext1"];
  };
  "/api/v1/config": {
    /** @description Get dynamic configuration information. */
    get: operations["getConfig"];
    /** @description Post dynamic configuration to Netdata. */
    post: operations["postConfig"];
  };
  "/api/v2/data": {
    /**
     * Data Query v2
     * @description Multi-node, multi-context, multi-instance, multi-dimension data queries, with time and metric aggregation.
     */
    get: operations["dataQuery2"];
  };
  "/api/v1/data": {
    /**
     * Data Query v1 - Single node, single chart or context queries. without group-by.
     * @description Query metric data of a chart or context of a node and return a dataset having time-series data for all dimensions available.
     * For group-by functionality, use `/api/v2/data`.
     * At least a `chart` or a `context` have to be given for the data query to be executed.
     */
    get: operations["dataQuery1"];
  };
  "/api/v1/allmetrics": {
    /**
     * All Metrics v1 - Fetch latest value for all metrics
     * @description The `allmetrics` endpoint returns the latest value of all metrics maintained for a netdata node.
     */
    get: operations["allMetrics1"];
  };
  "/api/v1/badge.svg": {
    /**
     * Generate a badge in form of SVG image for a chart (or dimension)
     * @description Successful responses are SVG images.
     */
    get: operations["badge1"];
  };
  "/api/v2/weights": {
    /**
     * Score or weight all or some of the metrics, across all nodes, according to various algorithms.
     * @description This endpoint goes through all metrics and scores them according to an algorithm.
     */
    get: operations["weights2"];
  };
  "/api/v1/weights": {
    /**
     * Score or weight all or some of the metrics of a single node, according to various algorithms.
     * @description This endpoint goes through all metrics and scores them according to an algorithm.
     */
    get: operations["weights1"];
  };
  "/api/v1/metric_correlations": {
    /**
     * Analyze all the metrics to find their correlations - EOL
     * @description THIS ENDPOINT IS OBSOLETE. Use the /weights endpoint. Given two time-windows (baseline, highlight), it goes through all the available metrics, querying both windows and tries to find how these two windows relate to each other. It supports multiple algorithms to do so. The result is a list of all metrics evaluated, weighted for 0.0 (the two windows are more different) to 1.0 (the two windows are similar). The algorithm adjusts automatically the baseline window to be a power of two multiple of the highlighted (1, 2, 4, 8, etc).
     */
    get: operations["metricCorrelations1"];
  };
  "/api/v1/function": {
    /** @description Execute a collector function. */
    get: operations["function1"];
  };
  "/api/v1/functions": {
    /**
     * Get a list of all registered collector functions.
     * @description Collector functions are programs that can be executed on demand.
     */
    get: operations["functions1"];
  };
  "/api/v1/alarms": {
    /**
     * Get a list of active or raised alarms on the server
     * @description The alarms endpoint returns the list of all raised or enabled alarms on the netdata server. Called without any parameters, the raised alarms in state WARNING or CRITICAL are returned. By passing "?all", all the enabled alarms are returned.
     */
    get: operations["alerts1"];
  };
  "/api/v1/alarms_values": {
    /**
     * Get a list of active or raised alarms on the server
     * @description The alarms_values endpoint returns the list of all raised or enabled alarms on the netdata server. Called without any parameters, the raised alarms in state WARNING or CRITICAL are returned. By passing '?all', all the enabled alarms are returned. This option output differs from `/alarms` in the number of variables delivered. This endpoint gives to user `id`, `value`, `last_updated` time, and alarm `status`.
     */
    get: operations["alertValues1"];
  };
  "/api/v1/alarm_log": {
    /**
     * Retrieves the entries of the alarm log
     * @description Returns an array of alarm_log entries, with historical information on raised and cleared alarms.
     */
    get: operations["alertsLog1"];
  };
  "/api/v1/alarm_count": {
    /**
     * Get an overall status of the chart
     * @description Checks multiple charts with the same context and counts number of alarms with given status.
     */
    get: operations["alertsCount1"];
  };
  "/api/v1/alarm_variables": {
    /**
     * List variables available to configure alarms for a chart
     * @description Returns the basic information of a chart and all the variables that can be used in alarm and template health configurations for the particular chart or family.
     */
    get: operations["getNodeAlertVariables1"];
  };
  "/api/v1/manage/health": {
    /**
     * Accesses the health management API to control health checks and notifications at runtime.
     *
     * @description Available from Netdata v1.12 and above, protected via bearer authorization. Especially useful for maintenance periods, the API allows you to disable health checks completely, silence alarm notifications, or Disable/Silence specific alarms that match selectors on alarm/template name, chart, context, host and family. For the simple disable/silence all scenarios, only the cmd parameter is required. The other parameters are used to define alarm selectors. For more information and examples, refer to the netdata documentation.
     */
    get: operations["health1"];
  };
  "/api/v1/aclk": {
    /**
     * Get information about current ACLK state
     * @description ACLK endpoint returns detailed information about current state of ACLK (Agent to Cloud communication).
     */
    get: operations["aclk1"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    info: {
      /**
       * @description netdata version of the server.
       * @example 1.11.1_rolling
       */
      version?: string;
      /**
       * @description netdata unique id of the server.
       * @example 24e9fe3c-f2ac-11e8-bafc-0242ac110002
       */
      uid?: string;
      /**
       * @description List of hosts mirrored of the server (include itself).
       * @example [
       *   "host1.example.com",
       *   "host2.example.com"
       * ]
       */
      mirrored_hosts?: string[];
      /** @description List of details of hosts mirrored to this served (including self). Indexes correspond to indexes in "mirrored_hosts". */
      mirrored_hosts_status?: ({
          /**
           * Format: uuid
           * @description Host unique GUID from `netdata.public.unique.id`.
           * @example 245e4bff-3b34-47c1-a6e5-5c535a9abfb2
           */
          guid?: string;
          /** @description Current state of streaming. Always true for localhost/self. */
          reachable?: boolean;
          /**
           * Format: uuid
           * @description Cloud GUID/identifier in case the host is claimed. If child status unknown or unclaimed this field is set to `null`
           * @example c3b2a66a-3052-498c-ac52-7fe9e8cccb0c
           */
          claim_id?: string | null;
        })[];
      /**
       * @description Operating System Name.
       * @example Manjaro Linux
       */
      os_name?: string;
      /**
       * @description Operating System ID.
       * @example manjaro
       */
      os_id?: string;
      /**
       * @description Known OS similar to this OS.
       * @example arch
       */
      os_id_like?: string;
      /**
       * @description Operating System Version.
       * @example 18.0.4
       */
      os_version?: string;
      /**
       * @description Operating System Version ID.
       * @example unknown
       */
      os_version_id?: string;
      /**
       * @description OS parameters detection method.
       * @example Mixed
       */
      os_detection?: string;
      /**
       * @description Kernel Name.
       * @example Linux
       */
      kernel_name?: string;
      /**
       * @description Kernel Version.
       * @example 4.19.32-1-MANJARO
       */
      kernel_version?: string;
      /**
       * @description Netdata is running on a K8s node.
       * @example false
       */
      is_k8s_node?: boolean;
      /**
       * @description Kernel architecture.
       * @example x86_64
       */
      architecture?: string;
      /**
       * @description Virtualization Type.
       * @example kvm
       */
      virtualization?: string;
      /**
       * @description Virtualization detection method.
       * @example systemd-detect-virt
       */
      virt_detection?: string;
      /**
       * @description Container technology.
       * @example docker
       */
      container?: string;
      /**
       * @description Container technology detection method.
       * @example dockerenv
       */
      container_detection?: string;
      /**
       * @description Stream transmission compression method.
       * @example true
       */
      stream_compression?: boolean;
      /** @description List of host labels. */
      labels?: {
        /**
         * @description Host label.
         * @example netdata
         */
        app?: string;
      };
      collectors?: {
          /**
           * @description Collector plugin.
           * @example python.d.plugin
           */
          plugin?: string;
          /**
           * @description Module of the collector plugin.
           * @example dockerd
           */
          module?: string;
        }[];
      /** @description Number of alarms in the server. */
      alarms?: {
        /** @description Number of alarms in normal state. */
        normal?: number;
        /** @description Number of alarms in warning state. */
        warning?: number;
        /** @description Number of alarms in critical state. */
        critical?: number;
      };
    };
    chart_summary: {
      /** @description The hostname of the netdata server. */
      hostname?: string;
      /** @description netdata version of the server. */
      version?: string;
      /**
       * @description The release channel of the build on the server.
       * @example nightly
       */
      release_channel?: string;
      /** @description The current timezone on the server. */
      timezone?: string;
      /**
       * @description The netdata server host operating system.
       * @enum {string}
       */
      os?: "macos" | "linux" | "freebsd";
      /** @description The duration, in seconds, of the round robin database maintained by netdata. */
      history?: number;
      /** @description The name of the database memory mode on the server. */
      memory_mode?: string;
      /** @description The default update frequency of the netdata server. All charts have an update frequency equal or bigger than this. */
      update_every?: number;
      /** @description An object containing all the chart objects available at the netdata server. This is used as an indexed array. The key of each chart object is the id of the chart. */
      charts?: {
        [key: string]: components["schemas"]["chart"];
      };
      /** @description The number of charts. */
      charts_count?: number;
      /** @description The total number of dimensions. */
      dimensions_count?: number;
      /** @description The number of alarms. */
      alarms_count?: number;
      /** @description The size of the round robin database in bytes. */
      rrd_memory_bytes?: number;
    };
    chart: {
      /** @description The unique id of the chart. */
      id?: string;
      /** @description The name of the chart. */
      name?: string;
      /** @description The type of the chart. Types are not handled by netdata. You can use this field for anything you like. */
      type?: string;
      /** @description The family of the chart. Families are not handled by netdata. You can use this field for anything you like. */
      family?: string;
      /** @description The title of the chart. */
      title?: string;
      /** @description The relative priority of the chart. Netdata does not care about priorities. This is just an indication of importance for the chart viewers to sort charts of higher priority (lower number) closer to the top. Priority sorting should only be used among charts of the same type or family. */
      priority?: number;
      /** @description True when the chart is enabled. Disabled charts do not currently collect values, but they may have historical values available. */
      enabled?: boolean;
      /** @description The unit of measurement for the values of all dimensions of the chart. */
      units?: string;
      /** @description The absolute path to get data values for this chart. You are expected to use this path as the base when constructing the URL to fetch data values for this chart. */
      data_url?: string;
      /**
       * @description The chart type.
       * @enum {string}
       */
      chart_type?: "line" | "area" | "stacked";
      /** @description The duration, in seconds, of the round robin database maintained by netdata. */
      duration?: number;
      /** @description The UNIX timestamp of the first entry (the oldest) in the round robin database. */
      first_entry?: number;
      /** @description The UNIX timestamp of the latest entry in the round robin database. */
      last_entry?: number;
      /** @description The update frequency of this chart, in seconds. One value every this amount of time is kept in the round robin database. */
      update_every?: number;
      /** @description An object containing all the chart dimensions available for the chart. This is used as an indexed array. For each pair in the dictionary: the key is the id of the dimension and the value is a dictionary containing the name." */
      dimensions?: {
        [key: string]: {
          /** @description The name of the dimension */
          name?: string;
        };
      };
      chart_variables?: {
        [key: string]: components["schemas"]["chart_variables"];
      };
      /** @description Chart health green threshold. */
      green?: number | null;
      /** @description Chart health red threshold. */
      red?: number | null;
    };
    context_summary: {
      /** @description The hostname of the netdata server. */
      hostname?: string;
      /** @description The unique installation id of this netdata server. */
      machine_guid?: string;
      /**
       * @description The unique node id of this netdata server at the hub.
       * @example nightly
       */
      node_id?: string;
      /** @description The unique handshake id of this netdata server and the hub. */
      claim_id?: string;
      /** @description The host labels associated with this netdata server. */
      host_labels?: Record<string, never>;
      /** @description An object containing all the context objects available at the netdata server. This is used as an indexed array. The key of each context object is the id of the context. */
      context?: {
        [key: string]: components["schemas"]["context"];
      };
    };
    context: {
      /** @description The version of this context. The number are not sequential, but bigger numbers depict a newer object. */
      version?: string;
      /** @description The version of this context, as known by hub. */
      hub_version?: string;
      /** @description The family of the context. When multiple charts of a context have different families, the netdata server replaces the different parts with [x], so that the context can have only one family. */
      family?: string;
      /** @description The title of the context. When multiple charts of a context have different titles, the netdata server replaces the different parts with [x], so that the context can have only one title. */
      title?: string;
      /** @description The relative priority of the context. When multiple contexts have different priorities, the minimum among them is selected as the priority of the context. */
      priority?: number;
      /** @description The unit of measurement for the values of all dimensions of the context. If multiple charts of context have different units, the latest collected is selected. */
      units?: string;
      /**
       * @description The chart type.
       * @enum {string}
       */
      chart_type?: "line" | "area" | "stacked";
      /** @description The UNIX timestamp of the first entry (the oldest) in the database. */
      first_time_t?: number;
      /** @description The UNIX timestamp of the latest entry in the database. */
      last_time_t?: number;
      /** @description An object containing all the charts available for the chart. This is used as an indexed array. For each pair in the dictionary, the key is the id of the chart and the value provides all details about the chart. */
      charts?: Record<string, never>;
    };
    alarm_variables: {
      /** @description The unique id of the chart. */
      chart?: string;
      /** @description The name of the chart. */
      chart_name?: string;
      /** @description The context of the chart. It is shared across multiple monitored software or hardware instances and used in alarm templates. */
      cnart_context?: string;
      /** @description The family of the chart. */
      family?: string;
      /** @description The host containing the chart. */
      host?: string;
      chart_variables?: {
        [key: string]: components["schemas"]["chart_variables"];
      };
      family_variables?: {
        /** Format: float */
        varname1?: number;
        /** Format: float */
        varname2?: number;
      };
      host_variables?: {
        /** Format: float */
        varname1?: number;
        /** Format: float */
        varname2?: number;
      };
    };
    chart_variables: {
      /** Format: float */
      varname1?: number;
      /** Format: float */
      varname2?: number;
    };
    /** @description Data response with `format=json2` */
    jsonwrap2: {
      api?: components["schemas"]["api"];
      agents?: components["schemas"]["agents"];
      versions?: components["schemas"]["versions"];
      /** @description Summarized information about nodes, contexts, instances, labels, alerts, and dimensions. The items returned are determined by the scope of the query only, however the statistical data in them are influenced by the filters of the query. Using this information the dashboard allows users to slice and dice the data by filtering and grouping. */
      summary?: {
        nodes?: components["schemas"]["nodeWithDataStatistics"][];
        contexts?: ({
            /** @description the context id. */
            id?: string;
            is?: components["schemas"]["jsonwrap2_items_count"];
            ds?: components["schemas"]["jsonwrap2_items_count"];
            al?: components["schemas"]["jsonwrap2_alerts_count"];
            sts?: components["schemas"]["jsonwrap2_sts"] | components["schemas"]["jsonwrap2_sts_raw"];
          })[];
        instances?: ({
            /** @description the id of the instance. */
            id?: string;
            /** @description the name of the instance (may be absent when it is the same with the id) */
            nm?: string;
            /** @description the node index id this instance belongs to. The UI uses this to compone the fully qualified name of the instance, using the node hostname to present it to users and its machine guid to add it to filters. */
            ni?: unknown;
            ds?: components["schemas"]["jsonwrap2_items_count"];
            al?: components["schemas"]["jsonwrap2_alerts_count"];
            sts?: components["schemas"]["jsonwrap2_sts"] | components["schemas"]["jsonwrap2_sts_raw"];
          })[];
        dimensions?: ({
            /** @description the id of the dimension. */
            id?: string;
            /** @description the name of the dimension (may be absent when it is the same with the id) */
            nm?: string;
            ds?: components["schemas"]["jsonwrap2_items_count"];
            sts?: components["schemas"]["jsonwrap2_sts"] | components["schemas"]["jsonwrap2_sts_raw"];
          })[];
        labels?: ({
            /** @description the key of the label. */
            id?: string;
            ds?: components["schemas"]["jsonwrap2_items_count"];
            sts?: components["schemas"]["jsonwrap2_sts"] | components["schemas"]["jsonwrap2_sts_raw"];
            /** @description An array of values for this key. */
            vl?: ({
                /** @description The value string */
                id?: string;
                ds?: components["schemas"]["jsonwrap2_items_count"];
                sts?: components["schemas"]["jsonwrap2_sts"] | components["schemas"]["jsonwrap2_sts_raw"];
              })[];
          })[];
        /** @description An array of all the unique alerts running, grouped by alert name (`nm` is available here) */
        alerts?: components["schemas"]["jsonwrap2_alerts_count"][];
      };
      totals?: {
        nodes?: components["schemas"]["jsonwrap2_items_count"];
        contexts?: components["schemas"]["jsonwrap2_items_count"];
        instances?: components["schemas"]["jsonwrap2_items_count"];
        dimensions?: components["schemas"]["jsonwrap2_items_count"];
        label_keys?: components["schemas"]["jsonwrap2_items_count"];
        label_key_values?: components["schemas"]["jsonwrap2_items_count"];
      };
      functions?: string[];
      db?: {
        /** @description The number of tiers this server is using. */
        tiers?: number;
        /** @description The minimum update every, in seconds, for all tiers and all metrics aggregated into this query. */
        update_every?: number;
        /** @description The minimum unix epoch timestamp of the retention across all tiers for all metrics aggregated into this query. */
        first_entry?: number;
        /** @description The maximum unix epoch timestamp of the retention across all tier for all metrics aggregated into this query. */
        last_entry?: number;
        /** @description An array with information for each of the tiers available, related to this query. */
        per_tier?: {
            /** @description The tier number of this tier, starting at 0. */
            tier?: number;
            /** @description The number of queries executed on this tier. Usually one query per metric is made, but the query may cross multiple tier, in which case more than one query per metric is made. */
            queries?: number;
            /** @description The number of points read from this tier. */
            points?: number;
            /** @description The minimum resolution of all metrics queried on this tier. */
            update_every?: number;
            /** @description The minimum unix epoch timestamp available across all metrics that used this tier. This reflects the oldest timestamp of the tier's retention. */
            first_entry?: number;
            /** @description The maximum unix epoch timestamp available across all metrics that used this tier. This reflects the newest timestamp of the tier's retention. */
            last_entry?: unknown;
          }[];
        /** @description The units of the database data */
        units?: string | string[];
        dimensions?: {
          /** @description An array with the dimension ids that uniquely identify the dimensions for this query. It is the same with `view.dimensions.ids`. */
          ids?: string[];
          /** @description An array with the units each dimension has in the database (independent of group-by aggregation that may override the units). */
          units?: string[];
          /** @description Statistics about the data collection points used for each dimension. */
          sts?: components["schemas"]["jsonwrap2_sts"] | components["schemas"]["jsonwrap2_sts_raw"];
        };
      };
      view?: {
        /** @description The title the chart should have. */
        title?: string;
        /** @description The format the `result` top level member has. Available on when `debug` flag is set. */
        format?: string;
        /** @description An array presenting all the options given to the query. Available on when `debug` flag is set. */
        options?: string[];
        /** @description The same as the parameter `time_group`. Available on when `debug` flag is set. */
        time_group?: string;
        /** @description The oldest unix epoch timestamp of the data returned in the `result`. */
        after?: number;
        /** @description The newest unix epoch timestamp of the data returned in the `result`. */
        before?: number;
        /**
         * @description Information related to trimming of the last few points of the `result`, that was required to remove (increasing) partial data.
         * Trimming is disabled when the `raw` option is given to the query.
         * This object is available only when the `debug` flag is set.
         */
        partial_data_trimming?: {
          /**
           * @description The maximum `update_every` for all metrics aggregated into the query.
           * Trimming is by default enabled at `view.before - max_update_every`, but only when `view.before >= now - max_update_every`.
           */
          max_update_every?: number;
          /**
           * @description The timestamp at which trimming can be enabled.
           * If this timestamp is greater or equal to `view.before`, there is no trimming.
           */
          expected_after?: number;
          /**
           * @description The timestamp at which trimming has been applied.
           * If this timestamp is greater or equal to `view.before`, there is no trimming.
           */
          trimmed_after?: unknown;
        };
        /** @description The number of points in `result`. Available only when `raw` is given. */
        points?: number;
        /** @description The units of the query. */
        units?: string | string[];
        /**
         * @description The default chart type of the query.
         *
         * @enum {string}
         */
        chart_type?: "line" | "area" | "stacked";
        /** @description Detailed information about the chart dimensions included in the `result`. */
        dimensions?: {
          /** @description An array with the order of the groupings performed. */
          grouped_by?: ("selected" | "dimension" | "instance" | "node" | "context" | "units" | "label:key1" | "label:key2" | "label:keyN")[];
          /** @description An array with the dimension ids that uniquely identify the dimensions for this query. */
          ids?: string[];
          /** @description An array with the dimension names to be presented to users. Names may be overlapping, but IDs are not. */
          names?: string[];
          /**
           * @description An array with the relative priorities of the dimensions.
           * Numbers may not be sequential or unique. The application is expected to order by this and then by name.
           */
          priorities?: number[];
          /** @description An array with the number of source metrics aggregated into each dimension. */
          aggregated?: number[];
          /** @description An array with the units each dimension has. */
          units?: string[];
          /** @description Statistics about the view points for each dimension. */
          sts?: components["schemas"]["jsonwrap2_sts"] | components["schemas"]["jsonwrap2_sts_raw"];
          /**
           * @description The labels associated with each dimension in the query.
           * This object is only available when the `group-by-labels` option is given to the query.
           */
          labels?: {
            /** @description An array having one entry for each of the dimensions of the query. */
            label_key1?: string[][];
          };
        };
        /** @description The minimum value of all points included in the `result`. */
        min?: number;
        /** @description The maximum value of all points included in the `result`. */
        max?: number;
      };
      result?: components["schemas"]["data_json_formats2"];
      timings?: Record<string, never>;
    };
    /** @description Statistical values */
    jsonwrap2_sts: {
      /** @description The minimum value of all metrics aggregated */
      min?: number;
      /** @description The maximum value of all metrics aggregated */
      max?: number;
      /** @description The average value of all metrics aggregated */
      avg?: number;
      /** @description The average anomaly rate of all metrics aggregated */
      arp?: number;
      /** @description The contribution percentage of all the metrics aggregated */
      con?: number;
    };
    /** @description Statistical values when `raw` option is given. */
    jsonwrap2_sts_raw: {
      /** @description The minimum value of all metrics aggregated */
      min?: number;
      /** @description The maximum value of all metrics aggregated */
      max?: number;
      /** @description The sum value of all metrics aggregated */
      sum?: number;
      /** @description The sum anomaly rate of all metrics aggregated */
      ars?: number;
      /** @description The volume of all the metrics aggregated */
      vol?: number;
      /** @description The count of all metrics aggregated */
      cnt?: number;
    };
    /** @description Depending on the placement of this object, `items` may be `nodes`, `contexts`, `instances`, `dimensions`, `label keys`, `label key-value pairs`. Furthermore, if the whole object is missing it should be assumed that all its members are zero. */
    jsonwrap2_items_count: {
      /** @description The number of items `selected` to query. If absent it is zero. */
      sl?: number;
      /** @description The number of items `excluded` from querying. If absent it is zero. */
      ex?: number;
      /** @description The number of items (out of `selected`) the query successfully `queried`.  If absent it is zero. */
      qr?: number;
      /** @description The number of items (from `selected`) that `failed` to be queried.  If absent it is zero. */
      fl?: number;
    };
    /** @description Counters about alert statuses. If this object is missing, it is assumed that all its members are zero. */
    jsonwrap2_alerts_count: {
      /** @description The name of the alert. Can be absent when the counters refer to more than one alert instances. */
      nm?: string;
      /** @description The number of CLEAR alerts. If absent, it is zero. */
      cl?: number;
      /** @description The number of WARNING alerts. If absent, it is zero. */
      wr?: number;
      /** @description The number of CRITICAL alerts. If absent, it is zero. */
      cr?: number;
      /** @description The number of alerts that are not CLEAR, WARNING, CRITICAL (so, they are "other").  If absent, it is zero. */
      ot?: number;
    };
    /** @description The version of the API used. */
    api: number;
    /** @description An array of agent definitions consulted to compose this response. */
    agents: {
        /**
         * Format: uuid
         * @description The agent machine GUID.
         */
        mg?: string;
        /**
         * Format: uuid
         * @description The agent cloud node ID.
         */
        nd?: string;
        /** @description The agent hostname. */
        nm?: string;
        /** @description The agent index ID for this agent, in this response. */
        ai?: number;
        /** @description The current unix epoch timestamp of this agent. */
        now?: number;
      }[];
    /** @description Hashes that allow the caller to detect important database changes of Netdata agents. */
    versions: {
      /** @description An auto-increment value that reflects the number of changes to the number of nodes maintained by the server. Everytime a node is added or removed, this number gets incremented. */
      nodes_hard_hash?: number;
      /** @description An auto-increment value that reflects the number of changes to the number of contexts maintained by the server. Everytime a context is added or removed, this number gets incremented. */
      contexts_hard_hash?: number;
      /** @description An auto-increment value that reflects the number of changes to the queue that sends contexts updates to Netdata Cloud. Everytime the contents of a context are updated, this number gets incremented. */
      contexts_soft_hash?: number;
      /** @description An auto-increment value that reflects the number of changes to the number of alerts. Everytime an alert is added or removed, this number gets incremented. */
      alerts_hard_hash?: number;
      /** @description An auto-increment value that reflects the number of alerts transitions. Everytime an alert transitions to a new state, this number gets incremented. */
      alerts_soft_hash?: number;
    };
    /** @description Basic information about a node. */
    nodeBasic: {
      /**
       * Format: UUID
       * @description The machine guid of the node. May not be available if the request is served by the Netdata Cloud.
       */
      mg?: string;
      /**
       * Format: UUID
       * @description The node id of the node. May not be available if the node is not registered to Netdata Cloud.
       */
      nd?: string;
      /** @description The name (hostname) of the node. */
      nm?: string;
      /** @description The node index id, a number that uniquely identifies this node for this query. */
      ni: number;
      /** @description Status information about the communication with this node. */
      st: {
        /** @description The agent index id that has been contacted for this node. */
        ai?: number;
        /** @description The HTTP response code of the response for this node. When working directly with an agent, this is always 200. If the `code` is missing, it should be assumed to be 200. */
        code?: number;
        /** @description A human readable description of the error, if any. If `msg` is missing, or is the empty string `""` or is `null`, there is no description associated with the current status. */
        msg?: string;
        /** @description The time in milliseconds this node took to respond, or if the local agent responded for this node, the time it needed to execute the query. If `ms` is missing, the time that was required to query this node is unknown. */
        ms?: number;
      };
    };
    nodeWithDataStatistics: components["schemas"]["nodeBasic"] & ({
      is?: components["schemas"]["jsonwrap2_items_count"];
      ds?: components["schemas"]["jsonwrap2_items_count"];
      al?: components["schemas"]["jsonwrap2_alerts_count"];
      sts?: components["schemas"]["jsonwrap2_sts"] | components["schemas"]["jsonwrap2_sts_raw"];
    });
    nodeFull: components["schemas"]["nodeBasic"] & ({
      /** @description The version of the Netdata Agent the node runs. */
      version?: string;
      /** @description How many hops away from the origin node, the queried one is. 0 means the agent itself is the origin node. */
      hops?: number;
      /**
       * @description The current state of the node on this agent.
       * @enum {string}
       */
      state?: "reachable" | "stale" | "offline";
    });
    context2Basic: {
      family?: string;
      priority?: number;
      first_entry?: number;
      last_entry?: number;
      live?: boolean;
    };
    /** @description `/api/v2/contexts` and `/api/v2/q` response about multi-node contexts hosted by a Netdata agent. */
    contexts2: {
      api?: components["schemas"]["api"];
      agents?: components["schemas"]["agents"];
      versions?: components["schemas"]["versions"];
      contexts?: {
        [key: string]: components["schemas"]["context2Basic"];
      };
    };
    /** @description Response will contain the appropriate subtype, e.g. data_json depending on the requested format. */
    jsonwrap1: {
      /** @description The API version this conforms to. */
      api?: number;
      /** @description The unique id of the chart. */
      id?: string;
      /** @description The name of the chart. */
      name?: string;
      /** @description The update frequency of this chart, in seconds. One value every this amount of time is kept in the round robin database (independently of the current view). */
      update_every?: number;
      /** @description The current view appropriate update frequency of this chart, in seconds. There is no point to request chart refreshes, using the same settings, more frequently than this. */
      view_update_every?: number;
      /** @description The UNIX timestamp of the first entry (the oldest) in the round robin database (independently of the current view). */
      first_entry?: number;
      /** @description The UNIX timestamp of the latest entry in the round robin database (independently of the current view). */
      last_entry?: number;
      /** @description The UNIX timestamp of the first entry (the oldest) returned in this response. */
      after?: number;
      /** @description The UNIX timestamp of the latest entry returned in this response. */
      before?: number;
      /** @description The minimum value returned in the current view. This can be used to size the y-series of the chart. */
      min?: number;
      /** @description The maximum value returned in the current view. This can be used to size the y-series of the chart. */
      max?: number;
      /** @description The dimension names of the chart as returned in the current view. */
      dimension_names?: string[];
      /** @description The dimension IDs of the chart as returned in the current view. */
      dimension_ids?: string[];
      /** @description The latest values collected for the chart (independently of the current view). */
      latest_values?: string[];
      /** @description The latest values returned with this response. */
      view_latest_values?: string[];
      /** @description The number of dimensions returned. */
      dimensions?: number;
      /** @description The number of rows / points returned. */
      points?: number;
      /** @description The format of the result returned. */
      format?: string;
      chart_variables?: {
        [key: string]: components["schemas"]["chart_variables"];
      };
      result?: components["schemas"]["data_json_formats1"];
    };
    /** @description Depending on the `format` given to a data query, any of the following may be returned. */
    data_json_formats1: components["schemas"]["data_json"] | components["schemas"]["data_datatable"] | components["schemas"]["data_csvjsonarray"] | components["schemas"]["data_array"] | components["schemas"]["data_txt"];
    /** @description Depending on the `format` given to a data query, any of the following may be returned. */
    data_json_formats2: components["schemas"]["data_json2"] | components["schemas"]["data_json_formats1"];
    data_json2: {
      /** @description The IDs of the dimensions returned. The first is always `time`. */
      labels?: string[];
      /** @description The format of each point returned. */
      point?: {
        /** @description The index of the value in each point. */
        value?: number;
        /** @description The index of the anomaly rate in each point. */
        arp?: number;
        /**
         * @description The index of the point annotations in each point.
         * This is a bitmap. `EMPTY = 1`, `RESET = 2`, `PARTIAL = 4`.
         * `EMPTY` means the point has no value.
         * `RESET` means that at least one metric aggregated experienced an overflow (a counter that wrapped).
         * `PARTIAL` means that this point should have more metrics aggregated into it, but not all metrics had data.
         */
        pa?: number;
        /**
         * @description The number of metrics aggregated into this point.
         * This exists only when the option `raw` is given to the query and the final aggregation point is NOT `percentage`.
         */
        count?: number;
        /**
         * @description The sum of the non-selected dimensions aggregated for this group item point.
         * This exists only when the option `raw` is given to the query and the final aggregation method is `percentage`.
         */
        hidden?: unknown;
      };
      data?: (number & unknown[])[];
    };
    /** @description Data response in `json` format. */
    data_json: {
      /** @description The dimensions retrieved from the chart. */
      labels?: string[];
      /** @description The data requested, one element per sample with each element containing the values of the dimensions described in the labels value. */
      data?: number[];
    };
    /** @description Data response in `csv`, `tsv`, `tsv-excel`, `ssv`, `ssv-comma`, `markdown`, `html` formats. */
    data_txt: string;
    /** @description Data response in `array` format. */
    data_array: number[];
    /** @description The first inner array contains strings showing the labels of each column, each subsequent array contains the values for each point in time. */
    data_csvjsonarray: unknown[][];
    /** @description Data response in datatable / datasource formats (suitable for Google Charts). */
    data_datatable: {
      cols?: {
          /** @description Always empty - for future use. */
          id: unknown;
          /** @description The dimension returned from the chart. */
          label: unknown;
          /** @description Always empty - for future use. */
          pattern: unknown;
          /** @description The type of data in the column / chart-dimension. */
          type: unknown;
          /** @description Contains any annotations for the column. */
          p?: unknown;
        }[];
      rows?: {
          c?: {
              /** @description Each value in the row is represented by an object named `c` with five v fields: data, null, null, 0, the value. This format is fixed by the Google Charts API." */
              v?: unknown;
            }[];
        }[];
    };
    alarms: {
      hostname?: string;
      /** Format: int32 */
      latest_alarm_log_unique_id?: number;
      status?: boolean;
      /** Format: int32 */
      now?: number;
      alarms?: {
        "chart-name.alarm-name"?: {
          /** Format: int32 */
          id?: number;
          /** @description Full alarm name. */
          name?: string;
          chart?: string;
          family?: string;
          /** @description Will be false only if the alarm is disabled in the configuration. */
          active?: boolean;
          /** @description Whether the health check for this alarm has been disabled via a health command API DISABLE command. */
          disabled?: boolean;
          /** @description Whether notifications for this alarm have been silenced via a health command API SILENCE command. */
          silenced?: boolean;
          exec?: string;
          recipient?: string;
          source?: string;
          units?: string;
          info?: string;
          status?: string;
          /** Format: int32 */
          last_status_change?: number;
          /** Format: int32 */
          last_updated?: number;
          /** Format: int32 */
          next_update?: number;
          /** Format: int32 */
          update_every?: number;
          /** Format: int32 */
          delay_up_duration?: number;
          /** Format: int32 */
          delay_down_duration?: number;
          /** Format: int32 */
          delay_max_duration?: number;
          /** Format: int32 */
          delay_multiplier?: number;
          /** Format: int32 */
          delay?: number;
          /** Format: int32 */
          delay_up_to_timestamp?: number;
          value_string?: string;
          no_clear_notification?: boolean;
          lookup_dimensions?: string;
          /** Format: int32 */
          db_after?: number;
          /** Format: int32 */
          db_before?: number;
          lookup_method?: string;
          /** Format: int32 */
          lookup_after?: number;
          /** Format: int32 */
          lookup_before?: number;
          lookup_options?: string;
          calc?: string;
          calc_parsed?: string;
          warn?: string;
          warn_parsed?: string;
          crit?: string;
          crit_parsed?: string;
          /** Format: int32 */
          warn_repeat_every?: number;
          /** Format: int32 */
          crit_repeat_every?: number;
          /** Format: nullable */
          green?: string;
          /** Format: nullable */
          red?: string;
          value?: number;
        };
      };
    };
    alarm_log_entry: {
      hostname?: string;
      /** Format: int32 */
      unique_id?: number;
      /** Format: int32 */
      alarm_id?: number;
      /** Format: int32 */
      alarm_event_id?: number;
      name?: string;
      chart?: string;
      family?: string;
      processed?: boolean;
      updated?: boolean;
      /** Format: int32 */
      exec_run?: number;
      exec_failed?: boolean;
      exec?: string;
      recipient?: string;
      /** Format: int32 */
      exec_code?: number;
      source?: string;
      units?: string;
      /** Format: int32 */
      when?: number;
      /** Format: int32 */
      duration?: number;
      /** Format: int32 */
      non_clear_duration?: number;
      status?: string;
      old_status?: string;
      /** Format: int32 */
      delay?: number;
      /** Format: int32 */
      delay_up_to_timestamp?: number;
      /** Format: int32 */
      updated_by_id?: number;
      /** Format: int32 */
      updates_id?: number;
      value_string?: string;
      old_value_string?: string;
      silenced?: string;
      info?: string;
      value?: number | null;
      old_value?: number | null;
    };
    alarms_values: {
      hostname?: string;
      /** @description HashMap with keys being alarm names */
      alarms?: {
        [key: string]: {
          id?: number;
          value?: number;
          /** Format: int32 */
          last_updated?: number;
          /** @enum {string} */
          status?: "REMOVED" | "UNDEFINED" | "UNINITIALIZED" | "CLEAR" | "RAISED" | "WARNING" | "CRITICAL" | "UNKNOWN";
        };
      };
    };
    aclk_state: {
      /** @description Describes whether this agent is capable of connection to the Cloud. False means agent has been built without ACLK component either on purpose (user choice) or due to missing dependency. */
      "aclk-available"?: string;
      /** @description Describes which ACLK version is currently used. */
      "aclk-version"?: number;
      /** @description List of supported protocols for communication with Cloud. */
      "protocols-supported"?: string[];
      /** @description Informs whether this agent has been added to a space in the cloud (User has to perform claiming). If false (user didn't perform claiming) agent will never attempt any cloud connection. */
      "agent-claimed"?: boolean;
      /**
       * Format: uuid
       * @description Unique ID this agent uses to identify when connecting to cloud
       */
      claimed_id?: string;
      /** @description Informs if this agent was connected to the cloud at the time this request has been processed. */
      online?: boolean;
      /**
       * @description Informs which protocol is used to communicate with cloud
       * @enum {string}
       */
      "used-cloud-protocol"?: "Old" | "New";
    };
    metric_correlations: {
      /** @description the start time of the highlighted window */
      after?: number;
      /** @description the end time of the highlighted window */
      before?: number;
      /** @description the duration of the highlighted window */
      duration?: number;
      /** @description the points of the highlighted window */
      points?: number;
      /** @description the start time of the baseline window */
      baseline_after?: number;
      /** @description the end time of the baseline window */
      baseline_before?: number;
      /** @description the duration of the baseline window */
      baseline_duration?: number;
      /** @description the points of the baseline window */
      baseline_points?: number;
      /** @description the grouping method across time */
      group?: string;
      /** @description the correlation method used */
      method?: string;
      /** @description a comma separated list of the query options set */
      options?: string;
      /** @description the number of dimensions returned in the result */
      correlated_dimensions?: unknown;
      /** @description the total number of dimensions evaluated */
      total_dimensions_count?: number;
      statistics?: {
        query_time_ms?: number;
        db_queries?: number;
        db_points_read?: number;
        query_result_points?: number;
        binary_searches?: number;
      };
      /** @description An object containing chart objects with their metrics correlations. */
      correlated_charts?: {
        "chart-id1"?: {
          context?: string;
          dimensions?: {
            "dimension1-name"?: number;
            "dimension2-name"?: number;
          };
        };
        "chart-id2"?: {
          context?: string;
          dimensions?: {
            "dimension1-name"?: number;
            "dimension2-name"?: number;
          };
        };
      };
    };
    weights2: Record<string, never>;
    weights: {
      /** @description the start time of the highlighted window */
      after?: number;
      /** @description the end time of the highlighted window */
      before?: number;
      /** @description the duration of the highlighted window */
      duration?: number;
      /** @description the points of the highlighted window */
      points?: number;
      /** @description the start time of the baseline window */
      baseline_after?: number;
      /** @description the end time of the baseline window */
      baseline_before?: number;
      /** @description the duration of the baseline window */
      baseline_duration?: number;
      /** @description the points of the baseline window */
      baseline_points?: number;
      /** @description the grouping method across time */
      group?: string;
      /** @description the correlation method used */
      method?: string;
      /** @description a comma separated list of the query options set */
      options?: string;
      /** @description the number of dimensions returned in the result */
      correlated_dimensions?: unknown;
      /** @description the total number of dimensions evaluated */
      total_dimensions_count?: number;
      statistics?: {
        query_time_ms?: number;
        db_queries?: number;
        db_points_read?: number;
        query_result_points?: number;
        binary_searches?: number;
      };
      /** @description A dictionary of weighted context objects. */
      contexts?: {
        [key: string]: components["schemas"]["weighted_context"];
      };
    };
    weighted_context: {
      /** @description The average weight of the context. */
      weight?: number;
      /** @description A dictionary of weighted chart objects. */
      charts?: {
        [key: string]: components["schemas"]["weighted_chart"];
      };
    };
    weighted_chart: {
      /** @description The average weight of the context. */
      weight?: number;
      /** @description A dictionary of weighted dimensions. */
      dimensions?: {
        [key: string]: components["schemas"]["weighted_dimension"];
      };
    };
    weighted_dimension: number;
    config_schema: {
      /** @description Standard JSON Schema object describing the schema of each configurable entity. */
      jsonSchema?: Record<string, never>;
      /** @description Schema for react-json-schema-form to drive the UI. Provides additional UI-specific configuration. */
      uiSchema?: Record<string, never>;
    };
    config_tree: {
      /** @description The version of dynamic configuration supported by the Netdata agent. */
      version?: number;
      /** @description A map of configuration entity paths, each containing one or more configurable entities. */
      tree?: {
        [key: string]: {
          [key: string]: components["schemas"]["config_entity"];
        };
      };
      attention?: components["schemas"]["config_attention"];
    };
    config_entity: {
      /** @description Can be 'single' for entities appearing once, 'template' for entities supporting multiple instances, or 'job' for jobs belonging to a template. */
      type?: string;
      /** @description The current status of the entity. Values include 'accepted', 'running', 'failed', 'disabled', 'incomplete', or 'orphan'. */
      status?: string;
      /** @description An array of the possible actions supported by this entity. */
      cmds?: string[];
      /** @description The source type of the configuration (e.g., 'internal', 'stock', 'user', 'discovered', 'dyncfg'). */
      source_type?: string;
      /** @description Additional information about the source, formatted as comma-separated name-value pairs. */
      source?: string;
      /** @description Indicates if this is an internal module (true) or an external plugin (false). */
      sync?: boolean;
      /** @description True if the entity is disabled by the user. */
      user_disabled?: boolean;
      /** @description True if the entity requires a restart after addition or update. */
      restart_required?: boolean;
      /** @description True if a previously saved configuration failed to apply after a restart. */
      plugin_rejected?: boolean;
      /** @description Object containing at least an 'available' boolean indicating if there's a saved configuration for this entity. */
      payload?: {
        available?: boolean;
      };
      /** @description The number of times this configuration has been saved to disk by the dynamic configuration manager. */
      saves?: number;
      /**
       * Format: int64
       * @description The timestamp in microseconds when this dynamic configuration was first created.
       */
      created_ut?: number;
      /**
       * Format: int64
       * @description The timestamp in microseconds when this dynamic configuration was last modified.
       */
      modified_ut?: number;
      /** @description Shows the template the job belongs to, applicable when type is 'job'. */
      template?: string;
    };
    config_attention: {
      degraded?: boolean;
      restart_required?: number;
      plugin_rejected?: number;
      status_failed?: number;
      status_incomplete?: number;
    };
    config_default_response: {
      /** @description The HTTP status code of the response. */
      status?: number;
      /** @description A descriptive message about the response or the action taken. */
      message?: string;
      /** @description The data payload of the response, contents vary depending on the specific request and action. */
      data?: {
        [key: string]: unknown;
      };
    };
  };
  responses: never;
  parameters: {
    /** @description A simple pattern limiting the nodes scope of the query. The scope controls both data and metadata response. The simple pattern is checked against the nodes' machine guid, node id and hostname. The default nodes scope is all nodes for which this agent has data for. Usually the nodes scope is used to slice the entire dashboard (e.g. the Global Nodes Selector at the Netdata Cloud overview dashboard). Both positive and negative simple pattern expressions are supported. */
    scopeNodes?: string;
    /** @description A simple pattern limiting the contexts scope of the query. The scope controls both data and metadata response. The default contexts scope is all contexts for which this agent has data for. Usually the contexts scope is used to slice data on the dashboard (e.g. each context based chart has its own contexts scope, limiting the chart to all the instances of the selected context). Both positive and negative simple pattern expressions are supported. */
    scopeContexts?: string;
    /** @description A simple pattern matching the nodes to be queried. This only controls the data response, not the metadata. The simple pattern is checked against the nodes' machine guid, node id, hostname. The default nodes selector is all the nodes matched by the nodes scope. Both positive and negative simple pattern expressions are supported. */
    filterNodes?: string;
    /** @description A simple pattern matching the contexts to be queried. This only controls the data response, not the metadata. Both positive and negative simple pattern expressions are supported. */
    filterContexts?: string;
    /** @description A simple pattern matching the instances to be queried. The simple pattern is checked against the instance `id`, the instance `name`, the fully qualified name of the instance `id` and `name`, like `instance@machine_guid`, where `instance` is either its `id` or `name`. Both positive and negative simple pattern expressions are supported. */
    filterInstances?: string;
    /** @description A simple pattern matching the labels to be queried. The simple pattern is checked against `name:value` of all the labels of all the eligible instances (as filtered by all the above: scope nodes, scope contexts, nodes, contexts and instances). Negative simple patterns should not be used in this filter. */
    filterLabels?: string;
    /** @description A simple pattern matching the alerts to be queried. The simple pattern is checked against the `name` of alerts and the combination of `name:status`, when status is one of `CLEAR`, `WARNING`, `CRITICAL`, `REMOVED`, `UNDEFINED`, `UNINITIALIZED`, of all the alerts of all the eligible instances (as filtered by all the above). A negative simple pattern will exclude the instances having the labels matched. */
    filterAlerts?: string;
    /** @description A simple patterns matching the dimensions to be queried. The simple pattern is checked against and `id` and the `name` of the dimensions of the eligible instances (as filtered by all the above). Both positive and negative simple pattern expressions are supported. */
    filterDimensions?: string;
    /** @description The format of the data to be returned. */
    dataFormat1?: "json" | "jsonp" | "csv" | "tsv" | "tsv-excel" | "ssv" | "ssvcomma" | "datatable" | "datasource" | "html" | "markdown" | "array" | "csvjsonarray";
    /** @description The format of the data to be returned. */
    dataFormat2?: "json" | "json2" | "jsonp" | "csv" | "tsv" | "tsv-excel" | "ssv" | "ssvcomma" | "datatable" | "datasource" | "html" | "markdown" | "array" | "csvjsonarray";
    /**
     * @description Options that affect data generation.
     * * `jsonwrap` - Wrap the output in a JSON object with metadata about the query.
     * * `raw` - change the output so that it is aggregatable across multiple such queries. Supported by `/api/v2` data queries and `json2` format.
     * * `minify` - Remove unnecessary spaces and newlines from the output.
     * * `debug` - Provide additional information in `jsonwrap` output to help tracing issues.
     * * `nonzero` - Do not return dimensions that all their values are zero, to improve the visual appearance of charts. They will still be returned if all the dimensions are entirely zero.
     * * `null2zero` - Replace `null` values with `0`.
     * * `absolute` or `abs` - Traditionally Netdata returns select dimensions negative to improve visual appearance. This option turns this feature off.
     * * `display-absolute` - Only used by badges, to do color calculation using the signed value, but render the value without a sign.
     * * `flip` or `reversed` - Order the timestamps array in reverse order (newest to oldest).
     * * `min2max` - When flattening multi-dimensional data into a single metric format, use `max - min` instead of `sum`. This is EOL - use `/api/v2` to control aggregation across dimensions.
     * * `percentage` - Convert all values into a percentage vs the row total. When enabled, Netdata will query all dimensions, even the ones that have not been selected or are hidden, to find the row total, in order to calculate the percentage of each dimension selected.
     * * `seconds` - Output timestamps in seconds instead of dates.
     * * `milliseconds` or `ms` - Output timestamps in milliseconds instead of dates.
     * * `unaligned` - by default queries are aligned to the the view, so that as time passes past data returned do not change. When a data query will not be used for visualization, `unaligned` can be given to avoid aligning the query time-frame for visual precision.
     * * `match-ids`, `match-names`. By default filters match both IDs and names when they are available. Setting either of the two options will disable the other.
     * * `anomaly-bit` - query the anomaly information instead of metric values. This is EOL, use `/api/v2` and `json2` format which always returns this information and many more.
     * * `jw-anomaly-rates` - return anomaly rates as a separate result set in the same `json` format response. This is EOL, use `/api/v2` and `json2` format which always returns information and many more.
     * * `details` - `/api/v2/data` returns in `jsonwrap` the full tree of dimensions that have been matched by the query.
     * * `group-by-labels` - `/api/v2/data` returns in `jsonwrap` flattened labels per output dimension. These are used to identify the instances that have been aggregated into each dimension, making it possible to provide a map, like Netdata does for Kubernetes.
     * * `natural-points` - return timestamps as found in the database. The result is again fixed-step, but the query engine attempts to align them with the timestamps found in the database.
     * * `virtual-points` - return timestamps independent of the database alignment. This is needed aggregating data across multiple Netdata agents, to ensure that their outputs do not need to be interpolated to be merged.
     * * `selected-tier` - use data exclusively from the selected tier given with the `tier` parameter. This option is set automatically when the `tier` parameter is set.
     * * `all-dimensions` - In `/api/v1` `jsonwrap` include metadata for all candidate metrics examined. In `/api/v2` this is standard behavior and no option is needed.
     * * `label-quotes` - In `csv` output format, enclose each header label in quotes.
     * * `objectrows` - Each row of value should be an object, not an array (only for `json` format).
     * * `google_json` - Comply with google JSON/JSONP specs (only for `json` format).
     */
    dataQueryOptions?: ("jsonwrap" | "raw" | "minify" | "debug" | "nonzero" | "null2zero" | "abs" | "absolute" | "display-absolute" | "flip" | "reversed" | "min2max" | "percentage" | "seconds" | "ms" | "milliseconds" | "unaligned" | "match-ids" | "match-names" | "anomaly-bit" | "jw-anomaly-rates" | "details" | "group-by-labels" | "natural-points" | "virtual-points" | "selected-tier" | "all-dimensions" | "label-quotes" | "objectrows" | "google_json")[];
    /** @description Time aggregation function. If multiple collected values are to be grouped in order to return fewer points, this parameters defines the method of grouping. If the `absolute` option is set, the values are turned positive before applying this calculation. */
    dataTimeGroup1?: "min" | "max" | "avg" | "average" | "median" | "stddev" | "sum" | "incremental-sum" | "ses" | "des" | "cv" | "countif" | "percentile" | "percentile25" | "percentile50" | "percentile75" | "percentile80" | "percentile90" | "percentile95" | "percentile97" | "percentile98" | "percentile99" | "trimmed-mean" | "trimmed-mean1" | "trimmed-mean2" | "trimmed-mean3" | "trimmed-mean5" | "trimmed-mean10" | "trimmed-mean15" | "trimmed-mean20" | "trimmed-mean25" | "trimmed-median" | "trimmed-median1" | "trimmed-median2" | "trimmed-median3" | "trimmed-median5" | "trimmed-median10" | "trimmed-median15" | "trimmed-median20" | "trimmed-median25";
    /** @description Time aggregation function. If multiple collected values are to be grouped in order to return fewer points, this parameters defines the method of grouping. If the `absolute` option is set, the values are turned positive before applying this calculation. */
    dataTimeGroup2?: "min" | "max" | "avg" | "average" | "median" | "stddev" | "sum" | "incremental-sum" | "ses" | "des" | "cv" | "countif" | "percentile" | "percentile25" | "percentile50" | "percentile75" | "percentile80" | "percentile90" | "percentile95" | "percentile97" | "percentile98" | "percentile99" | "trimmed-mean" | "trimmed-mean1" | "trimmed-mean2" | "trimmed-mean3" | "trimmed-mean5" | "trimmed-mean10" | "trimmed-mean15" | "trimmed-mean20" | "trimmed-mean25" | "trimmed-median" | "trimmed-median1" | "trimmed-median2" | "trimmed-median3" | "trimmed-median5" | "trimmed-median10" | "trimmed-median15" | "trimmed-median20" | "trimmed-median25";
    /** @description When the time grouping function supports additional parameters, this field can be used to pass them to it. Currently `countif`, `trimmed-mean`, `trimmed-median` and `percentile` support this. For `countif` the string may start with `<`, `<=`, `<:`, `<>`, `!=`, `>`, `>=`, `>:`. For all others just a number is expected. */
    dataTimeGroupOptions1?: string;
    /** @description When the time grouping function supports additional parameters, this field can be used to pass them to it. Currently `countif`, `trimmed-mean`, `trimmed-median` and `percentile` support this. For `countif` the string may start with `<`, `<=`, `<:`, `<>`, `!=`, `>`, `>=`, `>:`. For all others just a number is expected. */
    dataTimeGroupOptions2?: string;
    /** @description The grouping number of seconds. This is used in conjunction with group=average to change the units of metrics (ie when the data is per-second, setting gtime=60 will turn them to per-minute). */
    dataTimeResampling1?: number;
    /** @description For incremental values that are "per second", this value is used to resample them to "per minute` (60) or "per hour" (3600). It can only be used in conjunction with group=average. */
    dataTimeResampling2?: number;
    /** @description Specify a timeout value in milliseconds after which the agent will abort the query and return a 503 error. A value of 0 indicates no timeout. */
    timeoutMS?: number;
    /** @description Specify a timeout value in seconds after which the agent will abort the query and return a 504 error. A value of 0 indicates no timeout, but some endpoints, like `weights`, do not accept infinite timeouts (they have a predefined default), so to disable the timeout it must be set to a really high value. */
    timeoutSecs?: number;
    /** @description `after` and `before` define the time-frame of a query. `before` can be a negative number of seconds, up to 3 years (-94608000), relative to current clock. If not set, it is assumed to be the current clock time. When `before` is positive, it is assumed to be a unix epoch timestamp. When non-data endpoints support the `after` and `before`, they use the time-frame to limit their response for objects having data retention within the time-frame given. */
    before?: number;
    /** @description `after` and `before` define the time-frame of a query. `after` can be a negative number of seconds, up to 3 years (-94608000), relative to `before`. If not set, it is usually assumed to be -600. When non-data endpoints support the `after` and `before`, they use the time-frame to limit their response for objects having data retention within the time-frame given. */
    after?: number;
    /** @description `baseline_after` and `baseline_before` define the baseline time-frame of a comparative query. `baseline_before` can be a negative number of seconds, up to 3 years (-94608000), relative to current clock. If not set, it is assumed to be the current clock time. When `baseline_before` is positive, it is assumed to be a unix epoch timestamp. */
    baselineBefore?: number;
    /** @description `baseline_after` and `baseline_before` define the baseline time-frame of a comparative query. `baseline_after` can be a negative number of seconds, up to 3 years (-94608000), relative to `baseline_before`. If not set, it is usually assumed to be -300. */
    baselineAfter?: number;
    /** @description The number of points to be returned. If not given, or it is <= 0, or it is bigger than the points stored in the database for the given duration, all the available collected values for the given duration will be returned. For `weights` endpoints that do statistical analysis, the `points` define the detail of this analysis (the default is 500). */
    points?: number;
    /** @description Use only the given dbengine tier for executing the query. Setting this parameters automatically sets the option `selected-tier` for the query. */
    tier?: number;
    /** @description For JSONP responses, the callback function name. */
    callback?: string;
    /** @description Add `Content-Disposition: attachment; filename=` header to the response, that will instruct the browser to save the response with the given filename." */
    filename?: string;
    /** @description [Google Visualization API](https://developers.google.com/chart/interactive/docs/dev/implementing_data_source?hl=en) formatted parameter. */
    tqx?: string;
    /** @description Options that affect data generation. */
    contextOptions1?: ("full" | "all" | "charts" | "dimensions" | "labels" | "uuids" | "queue" | "flags" | "deleted" | "deepscan")[];
    /** @description The id of the chart as returned by the `/api/v1/charts` call. */
    chart?: string;
    /** @description The context of the chart as returned by the /charts call. */
    context?: string;
    /** @description Zero, one or more dimension ids or names, as returned by the /chart call, separated with comma or pipe. Netdata simple patterns are supported. */
    dimension?: string[];
    /** @description a simple pattern matching dimensions (use comma or pipe as separator) */
    dimensions?: string;
    /** @description Specify the chart label keys that need to match for context queries as comma separated values. At least one matching key is needed to match the corresponding chart. */
    chart_label_key?: string;
    /** @description Specify the chart label keys and values to match for context queries. All keys/values need to match for the chart to be included in the query. The labels are specified as key1:value1,key2:value2 */
    chart_labels_filter?: string;
    /** @description The weighting / scoring algorithm. */
    weightMethods?: "ks2" | "volume" | "anomaly-rate" | "value";
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Nodes Info v2
   * @description Get a list of all nodes hosted by this Netdata agent.
   */
  getNodes2: {
    parameters: {
      query?: {
        scope_nodes?: components["parameters"]["scopeNodes"];
        scope_contexts?: components["parameters"]["scopeContexts"];
        nodes?: components["parameters"]["filterNodes"];
        contexts?: components["parameters"]["filterContexts"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": {
            api?: components["schemas"]["api"];
            agents?: components["schemas"]["agents"];
            versions?: components["schemas"]["versions"];
            nodes?: components["schemas"]["nodeFull"][];
          };
        };
      };
    };
  };
  /**
   * Contexts Info v2
   * @description Get a list of all contexts, across all nodes, hosted by this Netdata agent.
   */
  getContexts2: {
    parameters: {
      query?: {
        scope_nodes?: components["parameters"]["scopeNodes"];
        scope_contexts?: components["parameters"]["scopeContexts"];
        nodes?: components["parameters"]["filterNodes"];
        contexts?: components["parameters"]["filterContexts"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["contexts2"];
        };
      };
    };
  };
  /**
   * Full Text Search v2
   * @description Get a list of contexts, across all nodes, hosted by this Netdata agent, matching a string expression
   */
  q2: {
    parameters: {
      query: {
        /** @description The strings to search for, formatted as a simple pattern */
        q: string;
        scope_nodes?: components["parameters"]["scopeNodes"];
        scope_contexts?: components["parameters"]["scopeContexts"];
        nodes?: components["parameters"]["filterNodes"];
        contexts?: components["parameters"]["filterContexts"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["contexts2"];
        };
      };
    };
  };
  /**
   * Node Info v1
   * @description The info endpoint returns basic information about netdata. It provides:
   * * netdata version
   * * netdata unique id
   * * list of hosts mirrored (includes itself)
   * * Operating System, Virtualization, K8s nodes and Container technology information
   * * List of active collector plugins and modules
   * * Streaming information
   * * number of alarms in the host
   *   * number of alarms in normal state
   *   * number of alarms in warning state
   *   * number of alarms in critical state
   */
  getNodeInfo1: {
    responses: {
      /** @description netdata basic information. */
      200: {
        content: {
          "application/json": components["schemas"]["info"];
        };
      };
      /** @description netdata daemon not ready (used for health checks). */
      503: {
        content: never;
      };
    };
  };
  /**
   * List all charts v1 - EOL
   * @description The charts endpoint returns a summary about all charts stored in the netdata server.
   */
  getNodeCharts1: {
    responses: {
      /** @description An array of charts. */
      200: {
        content: {
          "application/json": components["schemas"]["chart_summary"];
        };
      };
    };
  };
  /**
   * Get one chart v1 - EOL
   * @description The chart endpoint returns detailed information about a chart.
   */
  getNodeChart1: {
    parameters: {
      query?: {
        chart?: components["parameters"]["chart"];
      };
    };
    responses: {
      /** @description A javascript object with detailed information about the chart. */
      200: {
        content: {
          "application/json": components["schemas"]["chart"];
        };
      };
      /** @description No chart id was supplied in the request. */
      400: {
        content: never;
      };
      /** @description No chart with the given id is found. */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get a list of all node contexts available v1
   * @description The contexts endpoint returns a summary about all contexts stored in the netdata server.
   */
  getNodeContexts1: {
    parameters: {
      query?: {
        dimensions?: components["parameters"]["dimensions"];
        chart_label_key?: components["parameters"]["chart_label_key"];
        chart_labels_filter?: components["parameters"]["chart_labels_filter"];
        options?: components["parameters"]["contextOptions1"];
        after?: components["parameters"]["after"];
        before?: components["parameters"]["before"];
      };
    };
    responses: {
      /** @description An array of contexts. */
      200: {
        content: {
          "application/json": components["schemas"]["context_summary"];
        };
      };
    };
  };
  /**
   * Get info about a specific context
   * @description The context endpoint returns detailed information about a given context.
   * The `context` parameter is required for this call.
   */
  getNodeContext1: {
    parameters: {
      query?: {
        context?: components["parameters"]["context"];
        dimensions?: components["parameters"]["dimensions"];
        chart_label_key?: components["parameters"]["chart_label_key"];
        chart_labels_filter?: components["parameters"]["chart_labels_filter"];
        options?: components["parameters"]["contextOptions1"];
        after?: components["parameters"]["after"];
        before?: components["parameters"]["before"];
      };
    };
    responses: {
      /** @description A javascript object with detailed information about the context. */
      200: {
        content: {
          "application/json": components["schemas"]["context"];
        };
      };
      /** @description No context id was supplied in the request. */
      400: {
        content: never;
      };
      /** @description No context with the given id is found. */
      404: {
        content: never;
      };
    };
  };
  /** @description Get dynamic configuration information. */
  getConfig: {
    parameters: {
      query?: {
        /** @description The type of information required */
        action?: "tree" | "schema" | "get" | "enable" | "disable" | "restart";
        /** @description The ID of the dynamic configuration entity */
        id?: string;
        /** @description Top level path of the configuration entities, used with action 'tree' */
        path?: string;
        /** @description The timeout in seconds */
        timeout?: number;
      };
    };
    responses: {
      /** @description The call was successful. */
      200: {
        content: {
          "application/json": components["schemas"]["config_default_response"] | components["schemas"]["config_tree"] | components["schemas"]["config_schema"];
        };
      };
      /** @description Something is wrong with the request. */
      400: {
        content: {
          "application/json": components["schemas"]["config_default_response"];
        };
      };
      /** @description The configurable entity requests is not found. */
      404: {
        content: {
          "application/json": components["schemas"]["config_default_response"];
        };
      };
    };
  };
  /** @description Post dynamic configuration to Netdata. */
  postConfig: {
    parameters: {
      query?: {
        /** @description The type of action required. */
        action?: "add" | "test" | "update";
        /** @description The ID of the dynamic configuration entity to configure. */
        id?: string;
        /** @description Name of the dynamic configuration entity, used with action 'add' */
        name?: string;
        /** @description The timeout in seconds */
        timeout?: number;
      };
    };
    responses: {
      /** @description The call was successful. This also means the configuration is currently running. */
      200: {
        content: {
          "application/json": components["schemas"]["config_default_response"];
        };
      };
      /** @description The call was successful. The configuration has been accepted, but its status is not yet known. */
      202: {
        content: {
          "application/json": components["schemas"]["config_default_response"];
        };
      };
      /** @description The call was successful. The configuration has been accepted, but a restart is required to apply it. */
      299: {
        content: {
          "application/json": components["schemas"]["config_default_response"];
        };
      };
      /** @description Something is wrong with the request. */
      400: {
        content: {
          "application/json": components["schemas"]["config_default_response"];
        };
      };
      /** @description The configurable entity requests is not found. */
      404: {
        content: {
          "application/json": components["schemas"]["config_default_response"];
        };
      };
    };
  };
  /**
   * Data Query v2
   * @description Multi-node, multi-context, multi-instance, multi-dimension data queries, with time and metric aggregation.
   */
  dataQuery2: {
    parameters: {
      query?: {
        /**
         * @description A comma separated list of the groupings required.
         * All possible values can be combined together, except `selected`. If `selected` is given in the list, all others are ignored.
         * The order they are placed in the list is currently ignored.
         * This parameter is also accepted as `group_by[0]` and `group_by[1]` when multiple grouping passes are required.
         */
        group_by?: ("dimension" | "instance" | "percentage-of-instance" | "label" | "node" | "context" | "units" | "selected")[];
        /**
         * @description A comma separated list of the label keys to group by their values. The order of the labels in the list is respected.
         * This parameter is also accepted as `group_by_label[0]` and `group_by_label[1]` when multiple grouping passes are required.
         */
        group_by_label?: string;
        /**
         * @description The aggregation function to apply when grouping metrics together.
         * When option `raw` is given, `average` and `avg` behave like `sum` and the caller is expected to calculate the average.
         * This parameter is also accepted as `aggregation[0]` and `aggregation[1]` when multiple grouping passes are required.
         */
        aggregation?: "min" | "max" | "avg" | "average" | "sum" | "percentage";
        scope_nodes?: components["parameters"]["scopeNodes"];
        scope_contexts?: components["parameters"]["scopeContexts"];
        nodes?: components["parameters"]["filterNodes"];
        contexts?: components["parameters"]["filterContexts"];
        instances?: components["parameters"]["filterInstances"];
        labels?: components["parameters"]["filterLabels"];
        alerts?: components["parameters"]["filterAlerts"];
        dimensions?: components["parameters"]["filterDimensions"];
        after?: components["parameters"]["after"];
        before?: components["parameters"]["before"];
        points?: components["parameters"]["points"];
        tier?: components["parameters"]["tier"];
        options?: components["parameters"]["dataQueryOptions"];
        time_group?: components["parameters"]["dataTimeGroup2"];
        time_group_options?: components["parameters"]["dataTimeGroupOptions2"];
        time_resampling?: components["parameters"]["dataTimeResampling2"];
        format?: components["parameters"]["dataFormat2"];
        timeout?: components["parameters"]["timeoutMS"];
        callback?: components["parameters"]["callback"];
        filename?: components["parameters"]["filename"];
        tqx?: components["parameters"]["tqx"];
      };
    };
    responses: {
      /** @description The call was successful. The response includes the data in the format requested. */
      200: {
        content: {
          "application/json": components["schemas"]["jsonwrap2"] | components["schemas"]["data_json_formats2"];
          "text/plain": string;
          "text/html": string;
          "application/x-javascript": string;
        };
      };
      /** @description Bad request - the body will include a message stating what is wrong. */
      400: {
        content: never;
      };
      /** @description Internal server error. This usually means the server is out of memory. */
      500: {
        content: never;
      };
    };
  };
  /**
   * Data Query v1 - Single node, single chart or context queries. without group-by.
   * @description Query metric data of a chart or context of a node and return a dataset having time-series data for all dimensions available.
   * For group-by functionality, use `/api/v2/data`.
   * At least a `chart` or a `context` have to be given for the data query to be executed.
   */
  dataQuery1: {
    parameters: {
      query?: {
        chart?: components["parameters"]["chart"];
        context?: components["parameters"]["context"];
        dimension?: components["parameters"]["dimension"];
        chart_label_key?: components["parameters"]["chart_label_key"];
        chart_labels_filter?: components["parameters"]["chart_labels_filter"];
        after?: components["parameters"]["after"];
        before?: components["parameters"]["before"];
        points?: components["parameters"]["points"];
        tier?: components["parameters"]["tier"];
        options?: components["parameters"]["dataQueryOptions"];
        format?: components["parameters"]["dataFormat1"];
        group?: components["parameters"]["dataTimeGroup1"];
        group_options?: components["parameters"]["dataTimeGroupOptions1"];
        gtime?: components["parameters"]["dataTimeResampling1"];
        timeout?: components["parameters"]["timeoutMS"];
        callback?: components["parameters"]["callback"];
        filename?: components["parameters"]["filename"];
        tqx?: components["parameters"]["tqx"];
      };
    };
    responses: {
      /** @description The call was successful. The response includes the data in the format requested. */
      200: {
        content: {
          "application/json": {
            format: "json";
          } & (Omit<components["schemas"]["jsonwrap1"], "format"> | components["schemas"]["data_json_formats1"]);
          "text/plain": string;
          "text/html": string;
          "application/x-javascript": string;
        };
      };
      /** @description Bad request - the body will include a message stating what is wrong. */
      400: {
        content: never;
      };
      /** @description Chart or context is not found. The supplied chart or context will be reported. */
      404: {
        content: never;
      };
      /** @description Internal server error. This usually means the server is out of memory. */
      500: {
        content: never;
      };
    };
  };
  /**
   * All Metrics v1 - Fetch latest value for all metrics
   * @description The `allmetrics` endpoint returns the latest value of all metrics maintained for a netdata node.
   */
  allMetrics1: {
    parameters: {
      query: {
        /** @description The format of the response to be returned. */
        format: "shell" | "prometheus" | "prometheus_all_hosts" | "json";
        /** @description Allows to filter charts out using simple patterns. */
        filter?: string;
        /** @description When enabled, netdata will expose various system configuration variables. */
        variables?: "yes" | "no";
        /** @description Enable or disable timestamps in prometheus output. */
        timestamps?: "yes" | "no";
        /** @description When enabled netdata will report dimension names. When disabled netdata will report dimension IDs. The default is controlled in netdata.conf. */
        names?: "yes" | "no";
        /** @description When enabled, netdata will show metric names for the default `source=average` as they appeared before 1.12, by using the legacy unit naming conventions. */
        oldunits?: "yes" | "no";
        /** @description When enabled, netdata will not include the units in the metric names, for the default `source=average`. */
        hideunits?: "yes" | "no";
        /** @description Set a distinct name of the client querying prometheus metrics. Netdata will use the client IP if this is not set. */
        server?: string;
        /** @description Prefix all prometheus metrics with this string. */
        prefix?: string;
        /** @description Select the prometheus response data source. There is a setting in netdata.conf for the default. */
        data?: "as-collected" | "average" | "sum";
      };
    };
    responses: {
      /** @description All the metrics returned in the format requested. */
      200: {
        content: never;
      };
      /** @description The format requested is not supported. */
      400: {
        content: never;
      };
    };
  };
  /**
   * Generate a badge in form of SVG image for a chart (or dimension)
   * @description Successful responses are SVG images.
   */
  badge1: {
    parameters: {
      query?: {
        chart?: components["parameters"]["chart"];
        dimension?: components["parameters"]["dimension"];
        after?: components["parameters"]["after"];
        before?: components["parameters"]["before"];
        group?: components["parameters"]["dataTimeGroup1"];
        options?: components["parameters"]["dataQueryOptions"];
        /** @description The name of an alarm linked to the chart. */
        alarm?: string;
        /** @description A text to be used as the label. */
        label?: string;
        /** @description A text to be used as the units. */
        units?: string;
        /** @description A color to be used for the background of the label side(left side) of the badge. One of predefined colors or specific color in hex `RGB` or `RRGGBB` format (without preceding `#` character). If value wrong or not given default color will be used. */
        label_color?: ("green" | "brightgreen" | "yellow" | "yellowgreen" | "orange" | "red" | "blue" | "grey" | "gray" | "lightgrey" | "lightgray") | string;
        /** @description A color to be used for the background of the value *(right)* part of badge. You can set multiple using a pipe with a condition each, like this: `color<value|color:null` The following operators are supported: >, <, >=, <=, =, :null (to check if no value exists). Each color can be specified in same manner as for `label_color` parameter. Currently only integers are supported as values. */
        value_color?: string;
        /** @description Font color for label *(left)* part of the badge. One of predefined colors or as HTML hexadecimal color without preceding `#` character. Formats allowed `RGB` or `RRGGBB`. If no or wrong value given default color will be used. */
        text_color_lbl?: ("green" | "brightgreen" | "yellow" | "yellowgreen" | "orange" | "red" | "blue" | "grey" | "gray" | "lightgrey" | "lightgray") | string;
        /** @description Font color for value *(right)* part of the badge. One of predefined colors or as HTML hexadecimal color without preceding `#` character. Formats allowed `RGB` or `RRGGBB`. If no or wrong value given default color will be used. */
        text_color_val?: ("green" | "brightgreen" | "yellow" | "yellowgreen" | "orange" | "red" | "blue" | "grey" | "gray" | "lightgrey" | "lightgray") | string;
        /** @description Multiply the value with this number for rendering it at the image (integer value required). */
        multiply?: number;
        /** @description Divide the value with this number for rendering it at the image (integer value required). */
        divide?: number;
        /** @description Set the scale of the badge (greater or equal to 100). */
        scale?: number;
        /** @description This parameter overrides auto-sizing of badge and creates it with fixed width. This parameter determines the size of the label's left side *(label/name)*. You must set this parameter together with `fixed_width_val` otherwise it will be ignored. You should set the label/value widths wide enough to provide space for all the possible values/contents of the badge you're requesting. In case the text cannot fit the space given it will be clipped. The `scale` parameter still applies on the values you give to `fixed_width_lbl` and `fixed_width_val`. */
        fixed_width_lbl?: number;
        /** @description This parameter overrides auto-sizing of badge and creates it with fixed width. This parameter determines the size of the label's right side *(value)*. You must set this parameter together with `fixed_width_lbl` otherwise it will be ignored. You should set the label/value widths wide enough to provide space for all the possible values/contents of the badge you're requesting. In case the text cannot fit the space given it will be clipped. The `scale` parameter still applies on the values you give to `fixed_width_lbl` and `fixed_width_val`. */
        fixed_width_val?: number;
      };
    };
    responses: {
      /** @description The call was successful. The response should be an SVG image. */
      200: {
        content: never;
      };
      /** @description Bad request - the body will include a message stating what is wrong. */
      400: {
        content: never;
      };
      /** @description No chart with the given id is found. */
      404: {
        content: never;
      };
      /** @description Internal server error. This usually means the server is out of memory. */
      500: {
        content: never;
      };
    };
  };
  /**
   * Score or weight all or some of the metrics, across all nodes, according to various algorithms.
   * @description This endpoint goes through all metrics and scores them according to an algorithm.
   */
  weights2: {
    parameters: {
      query?: {
        method?: components["parameters"]["weightMethods"];
        scope_nodes?: components["parameters"]["scopeNodes"];
        scope_contexts?: components["parameters"]["scopeContexts"];
        nodes?: components["parameters"]["filterNodes"];
        contexts?: components["parameters"]["filterContexts"];
        instances?: components["parameters"]["filterInstances"];
        labels?: components["parameters"]["filterLabels"];
        alerts?: components["parameters"]["filterAlerts"];
        dimensions?: components["parameters"]["filterDimensions"];
        baseline_after?: components["parameters"]["baselineAfter"];
        baseline_before?: components["parameters"]["baselineBefore"];
        after?: components["parameters"]["after"];
        before?: components["parameters"]["before"];
        tier?: components["parameters"]["tier"];
        points?: components["parameters"]["points"];
        timeout?: components["parameters"]["timeoutMS"];
        options?: components["parameters"]["dataQueryOptions"];
        time_group?: components["parameters"]["dataTimeGroup2"];
        time_group_options?: components["parameters"]["dataTimeGroupOptions2"];
      };
    };
    responses: {
      /** @description JSON object with weights for each context, chart and dimension. */
      200: {
        content: {
          "application/json": components["schemas"]["weights2"];
        };
      };
      /** @description The given parameters are invalid. */
      400: {
        content: never;
      };
      /** @description metrics correlations are not enabled on this Netdata Agent. */
      403: {
        content: never;
      };
      /** @description No charts could be found, or the method that correlated the metrics did not produce any result. */
      404: {
        content: never;
      };
      /** @description Timeout - the query took too long and has been cancelled. */
      504: {
        content: never;
      };
    };
  };
  /**
   * Score or weight all or some of the metrics of a single node, according to various algorithms.
   * @description This endpoint goes through all metrics and scores them according to an algorithm.
   */
  weights1: {
    parameters: {
      query?: {
        method?: components["parameters"]["weightMethods"];
        context?: components["parameters"]["context"];
        baseline_after?: components["parameters"]["baselineAfter"];
        baseline_before?: components["parameters"]["baselineBefore"];
        after?: components["parameters"]["after"];
        before?: components["parameters"]["before"];
        tier?: components["parameters"]["tier"];
        points?: components["parameters"]["points"];
        timeout?: components["parameters"]["timeoutMS"];
        options?: components["parameters"]["dataQueryOptions"];
        group?: components["parameters"]["dataTimeGroup1"];
        group_options?: components["parameters"]["dataTimeGroupOptions1"];
      };
    };
    responses: {
      /** @description JSON object with weights for each context, chart and dimension. */
      200: {
        content: {
          "application/json": components["schemas"]["weights"];
        };
      };
      /** @description The given parameters are invalid. */
      400: {
        content: never;
      };
      /** @description metrics correlations are not enabled on this Netdata Agent. */
      403: {
        content: never;
      };
      /** @description No charts could be found, or the method that correlated the metrics did not produce any result. */
      404: {
        content: never;
      };
      /** @description Timeout - the query took too long and has been cancelled. */
      504: {
        content: never;
      };
    };
  };
  /**
   * Analyze all the metrics to find their correlations - EOL
   * @description THIS ENDPOINT IS OBSOLETE. Use the /weights endpoint. Given two time-windows (baseline, highlight), it goes through all the available metrics, querying both windows and tries to find how these two windows relate to each other. It supports multiple algorithms to do so. The result is a list of all metrics evaluated, weighted for 0.0 (the two windows are more different) to 1.0 (the two windows are similar). The algorithm adjusts automatically the baseline window to be a power of two multiple of the highlighted (1, 2, 4, 8, etc).
   */
  metricCorrelations1: {
    parameters: {
      query?: {
        method?: components["parameters"]["weightMethods"];
        baseline_after?: components["parameters"]["baselineAfter"];
        baseline_before?: components["parameters"]["baselineBefore"];
        after?: components["parameters"]["after"];
        before?: components["parameters"]["before"];
        points?: components["parameters"]["points"];
        tier?: components["parameters"]["tier"];
        timeout?: components["parameters"]["timeoutMS"];
        options?: components["parameters"]["dataQueryOptions"];
        group?: components["parameters"]["dataTimeGroup1"];
        group_options?: components["parameters"]["dataTimeGroupOptions1"];
      };
    };
    responses: {
      /** @description JSON object with weights for each chart and dimension. */
      200: {
        content: {
          "application/json": components["schemas"]["metric_correlations"];
        };
      };
      /** @description The given parameters are invalid. */
      400: {
        content: never;
      };
      /** @description metrics correlations are not enabled on this Netdata Agent. */
      403: {
        content: never;
      };
      /** @description No charts could be found, or the method that correlated the metrics did not produce any result. */
      404: {
        content: never;
      };
      /** @description Timeout - the query took too long and has been cancelled. */
      504: {
        content: never;
      };
    };
  };
  /** @description Execute a collector function. */
  function1: {
    parameters: {
      query: {
        /** @description The name of the function, as returned by the collector. */
        function: string;
        timeout?: components["parameters"]["timeoutSecs"];
      };
    };
    responses: {
      /** @description The collector function has been executed successfully. Each collector may return a different type of content. */
      200: {
        content: never;
      };
      /** @description The request was rejected by the collector. */
      400: {
        content: never;
      };
      /** @description The requested function is not found. */
      404: {
        content: never;
      };
      /** @description Other internal error, getting this error means there is a bug in Netdata. */
      500: {
        content: never;
      };
      /** @description The collector to execute the function is not currently available. */
      503: {
        content: never;
      };
      /** @description Timeout while waiting for the collector to execute the function. */
      504: {
        content: never;
      };
      /** @description The collector sent a response, but it was invalid or corrupted. */
      591: {
        content: never;
      };
    };
  };
  /**
   * Get a list of all registered collector functions.
   * @description Collector functions are programs that can be executed on demand.
   */
  functions1: {
    responses: {
      /** @description A JSON object containing one object per supported function. */
      200: {
        content: never;
      };
    };
  };
  /**
   * Get a list of active or raised alarms on the server
   * @description The alarms endpoint returns the list of all raised or enabled alarms on the netdata server. Called without any parameters, the raised alarms in state WARNING or CRITICAL are returned. By passing "?all", all the enabled alarms are returned.
   */
  alerts1: {
    parameters: {
      query?: {
        /** @description If passed, all enabled alarms are returned. */
        all?: boolean;
        /** @description If passed, the raised alarms in state WARNING or CRITICAL are returned. */
        active?: boolean;
      };
    };
    responses: {
      /** @description An object containing general info and a linked list of alarms. */
      200: {
        content: {
          "application/json": components["schemas"]["alarms"];
        };
      };
    };
  };
  /**
   * Get a list of active or raised alarms on the server
   * @description The alarms_values endpoint returns the list of all raised or enabled alarms on the netdata server. Called without any parameters, the raised alarms in state WARNING or CRITICAL are returned. By passing '?all', all the enabled alarms are returned. This option output differs from `/alarms` in the number of variables delivered. This endpoint gives to user `id`, `value`, `last_updated` time, and alarm `status`.
   */
  alertValues1: {
    parameters: {
      query?: {
        /** @description If passed, all enabled alarms are returned. */
        all?: boolean;
        /** @description If passed, the raised alarms in state WARNING or CRITICAL are returned. */
        active?: boolean;
      };
    };
    responses: {
      /** @description An object containing general info and a linked list of alarms. */
      200: {
        content: {
          "application/json": components["schemas"]["alarms_values"];
        };
      };
    };
  };
  /**
   * Retrieves the entries of the alarm log
   * @description Returns an array of alarm_log entries, with historical information on raised and cleared alarms.
   */
  alertsLog1: {
    parameters: {
      query?: {
        /** @description Passing the parameter after=UNIQUEID returns all the events in the alarm log that occurred after UNIQUEID. An automated series of calls would call the interface once without after=, store the last UNIQUEID of the returned set, and give it back to get incrementally the next events. */
        after?: number;
      };
    };
    responses: {
      /** @description An array of alarm log entries. */
      200: {
        content: {
          "application/json": components["schemas"]["alarm_log_entry"][];
        };
      };
    };
  };
  /**
   * Get an overall status of the chart
   * @description Checks multiple charts with the same context and counts number of alarms with given status.
   */
  alertsCount1: {
    parameters: {
      query?: {
        context?: components["parameters"]["context"];
        /** @description Specify alarm status to count. */
        status?: "REMOVED" | "UNDEFINED" | "UNINITIALIZED" | "CLEAR" | "RAISED" | "WARNING" | "CRITICAL";
      };
    };
    responses: {
      /** @description An object containing a count of alarms with given status for given contexts. */
      200: {
        content: {
          "application/json": number[];
        };
      };
      /** @description Internal server error. This usually means the server is out of memory. */
      500: {
        content: never;
      };
    };
  };
  /**
   * List variables available to configure alarms for a chart
   * @description Returns the basic information of a chart and all the variables that can be used in alarm and template health configurations for the particular chart or family.
   */
  getNodeAlertVariables1: {
    parameters: {
      query: {
        /** @description The id of the chart as returned by the /charts call. */
        chart: string;
      };
    };
    responses: {
      /** @description A javascript object with information about the chart and the available variables. */
      200: {
        content: {
          "application/json": components["schemas"]["alarm_variables"];
        };
      };
      /** @description Bad request - the body will include a message stating what is wrong. */
      400: {
        content: never;
      };
      /** @description No chart with the given id is found. */
      404: {
        content: never;
      };
      /** @description Internal server error. This usually means the server is out of memory. */
      500: {
        content: never;
      };
    };
  };
  /**
   * Accesses the health management API to control health checks and notifications at runtime.
   *
   * @description Available from Netdata v1.12 and above, protected via bearer authorization. Especially useful for maintenance periods, the API allows you to disable health checks completely, silence alarm notifications, or Disable/Silence specific alarms that match selectors on alarm/template name, chart, context, host and family. For the simple disable/silence all scenarios, only the cmd parameter is required. The other parameters are used to define alarm selectors. For more information and examples, refer to the netdata documentation.
   */
  health1: {
    parameters: {
      query?: {
        /** @description DISABLE ALL: No alarm criteria are evaluated, nothing is written in the alarm log. SILENCE ALL: No notifications are sent. RESET: Return to the default state. DISABLE/SILENCE: Set the mode to be used for the alarms matching the criteria of the alarm selectors. LIST: Show active configuration. */
        cmd?: "DISABLE ALL" | "SILENCE ALL" | "DISABLE" | "SILENCE" | "RESET" | "LIST";
        /** @description The expression provided will match both `alarm` and `template` names. */
        alarm?: string;
        /** @description Chart ids/names, as shown on the dashboard. These will match the `on` entry of a configured `alarm`. */
        chart?: string;
        /** @description Chart context, as shown on the dashboard. These will match the `on` entry of a configured `template`. */
        context?: string;
        /** @description The hostnames that will need to match. */
        hosts?: string;
      };
    };
    responses: {
      /** @description A plain text response based on the result of the command. */
      200: {
        content: never;
      };
      /** @description Bearer authentication error. */
      403: {
        content: never;
      };
    };
  };
  /**
   * Get information about current ACLK state
   * @description ACLK endpoint returns detailed information about current state of ACLK (Agent to Cloud communication).
   */
  aclk1: {
    responses: {
      /** @description JSON object with ACLK information. */
      200: {
        content: {
          "application/json": components["schemas"]["aclk_state"];
        };
      };
    };
  };
}
